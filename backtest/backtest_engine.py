# File: backtest/backtest_engine.py (Accurate equity curve from trades)
import os
import pandas as pd
from strategy.ema_crossover import ema_crossover_strategy
import warnings
warnings.filterwarnings("ignore")

def backtest(df, symbol="BTC/USDT", initial_balance=10000, short_window=5, long_window=9, leverage=1):
    # Apply the trading strategy to generate signals and record trades
    df = ema_crossover_strategy(df, symbol=symbol, short_window=short_window, long_window=long_window, capital=initial_balance)

    # Load trades from CSV log generated by the strategy
    trades_path = "logs/trades.csv"
    if not os.path.exists(trades_path):
        raise FileNotFoundError("Trade log not found. Ensure the strategy has generated trades.")

    trades_df = pd.read_csv(trades_path)

    # Compute equity curve from actual trade results
    equity = [initial_balance]
    for _, row in trades_df.iterrows():
        pnl = float(row['Exit Price']) - float(row['Entry Price'])
        pnl = pnl * float(row['Lot Size'])
        if row['Buy/Sell'] == 'Sell':
            pnl = -pnl  # reverse pnl for shorts
        equity.append(equity[-1] + pnl)

    # Align equity curve with DataFrame index
    equity_series = pd.Series(equity[1:], index=df.index[-len(equity)+1:])
    df['equity_curve'] = equity_series

    # Compute performance metrics
    total_return = equity[-1] - initial_balance
    win_rate = (trades_df['Result'] == 'Win').mean()
    max_drawdown = (df['equity_curve'] / df['equity_curve'].cummax() - 1).min()

    return df, total_return, win_rate, max_drawdown